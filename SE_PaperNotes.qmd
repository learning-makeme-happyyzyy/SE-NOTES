---
title: "Software Engineering: Mining Software Repositories"
subtitle: "Paper Notes"
author: "Zhouyiyang"
date: "2025年9月5日-2025年12月8日"
format:
  pdf:
    pdf-engine: xelatex
    documentclass: ctexart
    fontsize: 12pt
    include-in-header:
      text: |
        \setmainfont{Microsoft YaHei}   
        \setsansfont{SimHei}            
        \setmonofont{NSimSun}           
    toc: true
  docx: default
lang: zh-CN
---

# Paper:  Mining Email Social Networks

背景：large-scale software development projects invariably requrire a lot of communication and coordination(C&C) amonst the project workers
大规模软件项目往往需要项目工作者之间的大量的沟通与协调（C&C）。C&C在传统闭源项目中难以观察，而在开源项目OSS中邮件列表是公开的，提供了丰富的沟通记录。

具体来说，每一个开源项目都会设有一个或多个公开的邮件列表（mailing lists），项目中的利益相关者可以在这些列表上进行沟通与协作。所有的邮件交流都会被归档，并可供研究使用。

任何人都可以在OSS的mailing lists中发帖，且所有订阅者都可见这些邮件。发帖者包括：1.developers 2. bug reporters 3. contributors & users

大约73%的邮件可以至少引起一条回复，同时邮件代表了开发者之间的交流互动，绝大多数参与者只发过很少的邮件，也只收到极少的回复--- “二八分布”（Pareto 分布）

本研究的核心目标是：探讨开发者在邮件归档中所体现的沟通与协调（C&C）活动与他们在源代码中的开发行为之间的关系。我们特别关注以下几个问题：

1. 开发者的社交网络有哪些特征？

2. 在邮件列表中发送邮件频繁的开发者，是否也是代码提交最活跃的开发者？

3. 开发者与非开发者在社交网络中是否扮演不同角色？

4. 最活跃的开发者是否拥有最高的 “社会地位”？

重大技术挑战：别名（alias）识别问题，在邮件列表中，人们往往使用不同的电子邮件地址或昵称
（alias）发言，如果错误的把同一个活跃开发者的多个邮箱别名当成数个不太活跃的开发者，会严重影响结果的准确性。

自动化 + 人工相结合的混合方法来解决别名识别问题：

## Unmasking alias解除别名伪装

大多数电子邮件在信头header包含一个发件人片段，例如：

```{sql}
From: "Ben" <reddrum@google.com>
```

发件人是Ben，邮箱是...，在其他场合Ben可能使用截然不同的邮箱。

首先从每封邮件中提取<姓名，邮箱>作为标识符ID，随后对于任意两对ID执行聚类算法(clustering algorithm)来计算两对ID之间的相似度。如果两者姓名，邮箱相似，或者都相似，则归入同一cluster，之后由人工检查修正结果。

聚类算法细节：

Betweeness Centrality(BW)

*这是一篇presentation*

## slide 1:开场白
Hi everyone. Today I will present the paper *Mining Email Social Networks*, it's a really old paper, which explores the relationship between communication and code in Open-source software, using the Apache /əˈpætʃi/ HTTP Server project as a case study.

## slide 2：
We all know communication & coordintion are crucial in software engineering, but it's hard to measure especially in the traditional closed-source companies, where conversation happen behind closed-door.

While open-source software is different. They use public mailing lists, which creates a pefect, transparent trace of communication,
and this paper used this point.

So the big questions are: What social network emerge from these emails? What roles do developers play in the email social network? and crucially, how can we accurately link an email alias /ˈeɪliəs/ to a real person?

## slide 3:
For the data used, they extracted /ɪkˈstræktɪd/ from Apache HTTP server developer mailing lists starting in 1999. For each email extract these information from header.

Before we can analyze something, a fundational problem is identity confusion. Like a famous saying: On the internet, no one knows if you are a dog.

In practice, this means developers can use many different email addresses. 

If we fail to resolve it, the analysis would be completely wrong. like we may think one prolific developer is a dozen of different, 
less active developers, which will distort the social network.

## slide 4:
To solve this problem, the authors developed a hybrid, automated-plus-manual approach to handle the alias /ˈeɪliəs/.

Their algorithm clusters different email identities by checking three types of similarity:...

The automated process produced clusters, which were then maunually checked by the researchers. started with 2544 separate IDs and consolidated them
into 2012 different real individuals.

## slide 5:
With clean identity data, it's the time to build social network. The rule is simple: if person B replies to an email from person A, then draw a direct link from B to A.

this link means B found A's message worthy to respond.

From the social network, we calculate these key metrics: out-degree (prestige /preˈstiːʒ/), in-degree (engagement), betweeness, which mesures one's role as a broker or gatekeeper in the communication flow.

## slide 6:
Let's look at the data. these are four log-coordinate /koʊˈɔːrdɪneɪt , koʊˈɔːrdɪnət/ diagrams separatly show the distributions of message sent, number of repliy, out-degree, in-degree.
All the distributions show a very clear pattern: power-law distribution.

This means the community is highly uneven. A tiny /ˈtaɪni/ fraction of users accounts for the majority of messages, replies and communications.

## slide 7:
This is a scatter shows the relationship between the number of messages sent and the number of different people replying to them.

The spearman correlation is near-perfect 0.97 /zero point nine seven/, suggests a community survival effect: People who receive more and 
diverse /daɪˈvɜːrs/  feedback continue to be active, and those who don't, may disengage.

## slide 8:
This is a pruned /pruːnd/ email social network graph shows the replying relationship between those the most active developers.

These edges are the strongest links where at least 150 messages were exchanged. Forming a core circle.

## slide 9:
Finally, regarding the status of developers in social networks, they computed the betweeness of developers and non-developers in the full social network.
The mean betweenness of developers is 0.0114, and the mean betweenness of non-developer is 0.000140. A simple T-test indicates a t-value of 5.07, which is highly significant.

the second table shows what kind of work best predicts social status. It shows the spearman correlation between different activities and the social metrics defined before. 

The result is clear, source code contribution is the strongest predictor of a developer's core position in the social network. Document work, while important, does not confer the same level of social status.

## slide 10:
In conclusion, the paper provides a robust method for mining social network from open-source communication traces.

The key findings: small world structure in open-source software communication network; Second, the most active coders are also the social center of the project; And third, communication and code contribution are deeply linked.

Future works can include such as studying causality /kɔːˈzæləti/ over time and multiple-projects validation... Thank you.


# Paper: A Comprehensive Study of Autonomous Vehicle Bugs

## 研究目标

理解自动驾驶系统中软件缺陷的：

根本原因

表现症状

影响的软件组件

## 研究方法
研究对象：两大开源自动驾驶系统——Baidu Apollo 和 Autoware

数据来源：GitHub 上的 commit、issue、pull request

时间范围：截至2019年7月15日

分析样本：

16,851 个 commits

499 个被确认为 bug 的修复记录

## 分类体系
研究者构建了一个三层分类体系：

1. 根本原因（13类）
算法实现错误

数值计算错误

配置错误

条件判断缺失

内存错误

并发错误

文档错误

等

2. 症状（20类）
系统崩溃

编译/构建错误

速度控制错误

车道定位错误

轨迹规划错误

障碍物处理错误

显示/GUI错误

等

3. 受影响的组件（18类）
感知

定位

预测

规划

控制

地图引擎

CAN总线

工具与中间件

等

## 主要发现（16条）
算法实现错误是最常见的根本原因（27.86%）。

配置错误也非常常见（27.25%），尤其在 Autoware 中。

约 25.25% 的 bug 只需修改 ≤20 行代码，适合自动化修复。

28.06% 的 bug 直接影响驾驶行为（如速度控制、轨迹规划）。

规划组件是 bug 最多的模块（27.05%），远超其他组件。

构建错误和崩溃是常见症状，影响多个组件。

明确标记为安全/安全相关的 bug 极少（仅1%），但实际安全隐患可能被低估。

许多 bug 症状跨越多个组件，尤其是速度控制错误影响50%的组件。

## 研究意义与建议
对开发者：应重点关注规划、感知、定位等核心组件的测试与代码审查。

对研究者：

需要开发能处理多行代码修复的自动化工具。

应加强对配置管理和构建系统的支持。

应扩展测试范围，不仅限于感知组件（如目标检测），还应包括规划、控制等。

对未来：提出了构建自动驾驶系统测试用例生成、故障定位、自动修复等研究方向。

## 总结
这项研究首次系统性地揭示了自动驾驶系统中软件缺陷的特征，为后续的测试、调试、修复工具开发提供了重要基础，并指出了多个未来研究方向，尤其强调了对安全性和配置管理的重视。

## Q：
中文：
“‘算法错误’的平均修复需要修改超过100行代码。这些修改的本质是什么？是彻底重写了核心逻辑，还是在多处分散地打补丁？能否提供一个具体案例来说明为何这类修复对现有自动化工具构成挑战？”

English:
“Fixes for 'Algorithm Errors' require changing 100+ lines on average. What is the nature of these changes—are they core logic rewrites or scattered patches? Can you provide a concrete case to illustrate why such fixes challenge current automated repair tools?”

中文：
“为什么本研究没有分析Bug的‘触发条件’？一个错误是在常规驾驶中常见，还是需要极端边缘案例才能触发？了解这一点对于评估其真实世界中的风险至关重要。”

English:
“Why did the study not investigate bug 'triggering conditions'? Is a bug triggered during common driving scenarios or only by rare edge cases? Understanding this is crucial for assessing its real-world risk.”


# Paper: Striking Gold in Software Repositories? An Econometric Study of Cryptocurrencies on GitHub

本文对加密货币的市值与其在GitHub上的开源软件开发活动之间的关系进行了深入的实证研究。

## 研究核心问题

论文旨在探究一个直观的假设：一个加密货币的软件质量越高、开发越活跃，是否就越有价值？ 具体化为两个研究问题：

RQ1: 开发活跃度、受欢迎度和质量保证措施能否解释加密货币市值的差异？

RQ2: 这些软件指标与市值之间是否存在动态的因果关系？

## 研究方法与数据

数据来源： 追踪了241个开源加密货币项目在近一年内（347天）的日度数据。

软件指标： 从GitHub API收集，包括：

受欢迎度： Stars, Forks, Watchers

开发活跃度： Commits, Contributors, Lines of Code Changed

质量保证： 是否使用了CI（持续集成）和Badges（徽章）

金融指标： 从CoinMarketCap获取每日市值。

分析方法： 采用了计量经济学方法，包括线性回归和格兰杰因果检验，以探究变量间的静态关联和动态因果关系。

## 核心发现
1. 关于RQ1：静态关联

受欢迎度是关键： 在长期平均数据上，Stars数量与市值显示出显著的正相关关系。项目越受欢迎，平均市值越高。

开发活跃度不显著： Commits、代码行数变更、贡献者数量等开发活跃度指标，在控制了受欢迎度等因素后，并不能提供额外的解释力。

质量保证措施不显著： 虽然使用CI和Badges的加密货币平均市值略高，但这种关联在多元回归模型中并不显著。这表明，它们可能与受欢迎度等其他因素重合，而非独立的驱动因素。

结论： 只有受欢迎度（尤其是Stars）能解释市值的长期差异，而开发活动和质量保证实践本身并不直接关联更高的市值。

2. 关于RQ2：动态因果关系

没有令人信服的证据： 通过格兰杰因果检验，研究者发现几乎没有证据表明软件指标的变化能够预测未来市值的变化，反之亦然。

结果非常微弱： 在数百个项目的测试中，仅有极少数（例如，仅9个项目显示Stars能格兰杰引起市值变化）显示出统计显著性，且这些个案经检查后多被认为是偶然的同步波动，而非真正的因果关系。

结论： 软件指标的日常波动与市值的日常波动之间不存在可靠的动态领先或预测关系。

## 主要结论与启示

“表象”重于“实质”： 对于加密货币而言，在GitHub上看起来受欢迎（拥有大量Stars）比实际上的开发活跃度或代码质量更能关联其市场价值。这反映了市场情绪和社区关注度的力量。

无法通过“挖矿”软件仓库来短期套利： 软件指标的日常变化并不能作为可靠的先行指标来预测价格，试图通过监控GitHub活动来快速获利的策略很可能是无效的。

开源开发是“必需品”而非“增值项”： 拥有开源项目是加密货币领域的常态，但其开发活动的细微差别（至少在短期内）并非市场价格的主要驱动因素。

## 研究的局限性

时间范围： 仅研究了一年，可能不足以捕捉长期的因果关系。

市场环境： 研究期间市场整体呈下跌趋势，这可能影响了结果。

模型假设： 主要使用线性模型，而真实世界的关系可能是非线性的。

## Q：

中文：
“将CI和徽章的‘存在’等同于‘质量保证’是否合理？一个项目拥有CI配置，但若其测试薄弱或构建频繁失败，这还能代表高质量吗？”

English:
“Is it valid to equate the 'presence' of CI and badges with 'quality assurance'? If a project has a CI configuration but its tests are weak or builds frequently fail, does it still represent high quality?”