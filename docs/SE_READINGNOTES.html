<h1 id="研究背景与动机">研究背景与动机</h1>
<h2 id="se-3.0时代的到来">SE 3.0时代的到来</h2>
<ul>
<li>SE 1.0：传统手工编码时代，无AI辅助</li>
<li>SE 1.5：预测性编码（代码补全、智能提示）</li>
<li>SE 2.0：AI辅助软件工程（LLM生成代码）</li>
<li>SE 3.0：自主AI队友时代，能独立完成端到端开发任务</li>
</ul>
<h2 id="研究动机">研究动机</h2>
<ul>
<li>现有研究多为理论推测，缺乏真实世界中AI队友行为的实证数据</li>
<li>需要回答关键问题：
<ul>
<li>自主编码代理如何影响开发者生产力？</li>
<li>AI生成的代码是否可被合并？</li>
<li>人类团队如何适应自主编码代理的存在？</li>
<li>当前基准测试是否能反映AI在真实环境中的表现？</li>
</ul></li>
</ul>
<h1 id="主要贡献">主要贡献</h1>
<h2 id="aidev数据集">AIDev数据集</h2>
<ul>
<li>规模：456,535个由自主编码代理创建的PR</li>
<li>覆盖范围：61,453个GitHub仓库，47,303名开发者</li>
<li>包含的AI代理：OpenAI Codex、Devin、GitHub Copilot、Cursor、Claude
Code</li>
<li>数据结构：丰富的元数据，包括PR时间线、代码审查、提交详情、关联问题等</li>
</ul>
<h2 id="实证研究发现">实证研究发现</h2>
<ul>
<li>系统分析了AI代理在真实项目中的表现、审查动态和代码质量</li>
<li>揭示了基准测试表现与现实效果之间的显著差距</li>
</ul>
<h2 id="未来研究方向">未来研究方向</h2>
<ul>
<li>提出了9个具体的研究方向，指导SE与AI交叉领域的未来探索</li>
</ul>
<h1 id="关键研究发现">关键研究发现</h1>
<h2 id="生产力与接受率">生产力与接受率</h2>
<ul>
<li>AI代理已成为不可或缺的协作者，55%+的PR涉及功能开发或修复</li>
<li>AI-PR接受率显著低于人类（如Codex 64% vs 人类76.8%）</li>
<li>文档任务是AI的强项，接受率超过人类基准</li>
</ul>
<h2 id="效率与审查动态">效率与审查动态</h2>
<ul>
<li>GitHub Copilot完成速度极快（50%的PR在13分钟内完成）</li>
<li>OpenAI Codex PR审查速度快10倍（0.3小时 vs 人类3.9小时）</li>
<li>人类仍是主要审查者，但机器人审查比例在AI-PR中显著上升</li>
</ul>
<h2 id="代码质量与归属">代码质量与归属</h2>
<ul>
<li>AI更倾向于简单、模板化代码，较少引入复杂度变化</li>
<li>作者归属不明确，部分AI代理不标注贡献者，影响可追溯性</li>
<li>AI代理表现出语言偏好（如Codex偏向Python，Copilot偏向C#）</li>
</ul>
<h1 id="未来研究方向-1">未来研究方向</h1>
<h2 id="基准测试与评估">基准测试与评估</h2>
<ul>
<li>开发基于真实工作流的集成导向基准测试</li>
<li>分析被拒PR以识别AI失败模式</li>
</ul>
<h2 id="系统优化">系统优化</h2>
<ul>
<li>延迟感知的AI代理编排</li>
<li>设计智能PR分流系统管理审查工作量</li>
</ul>
<h2 id="质量与协作">质量与协作</h2>
<ul>
<li>评估AI代码的长期质量</li>
<li>研究人-AI协作中的任务规划阶段</li>
<li>研究编程语言特性对AI效果的影响</li>
</ul>
<h2 id="审查流程">审查流程</h2>
<ul>
<li>理解并降低审查AI代码的人力成本</li>
<li>改进AI代码审查的质量与流程</li>
</ul>
<h1 id="未来展望se-3.0方法论">未来展望：SE 3.0方法论</h1>
<h2 id="软件仓库作为ai训练环境">软件仓库作为AI训练环境</h2>
<ul>
<li>将GitHub仓库视为强化学习环境</li>
<li>使用真实信号（PR合并、测试通过）作为奖励</li>
</ul>
<h2 id="动态基准测试">动态基准测试</h2>
<ul>
<li>取代静态基准测试（如SWE-bench）</li>
<li>建立实时排行榜，反映真实项目集成效果</li>
</ul>
<h2 id="新工程方法论">新工程方法论</h2>
<ul>
<li>需要新的协作框架、审查机制和治理模型</li>
<li>重新定义敏捷、DevOps等实践以适应人-AI混合团队</li>
</ul>
<h1 id="结论">结论</h1>
<ul>
<li>AIDev提供了首个大规模实证基础，证明自主编码代理时代已经到来</li>
<li>AI代理能显著加速代码贡献，但在接受率和代码复杂性方面与人类存在差距</li>
<li>数据集将支持下一代软件工程研究，推动SE 3.0从理论走向实践</li>
</ul>
<h1 id="可以提出的问题">可以提出的问题：</h1>
<ol>
<li>混淆变量：
研究发现AI-PR的接受率更低。我们如何确定这是因为代码质量差，而不是因为人类审查员对AI生成的代码抱有固有的不信任或更高的审查标准？这一点可能会影响因果推断</li>
</ol>
<p>Regarding potential confounding variables: The empirical findings
indicate a systematically lower acceptance rate for Agentic-PRs. How can
we ascertain that this is primarily due to inferior code quality, as
opposed to inherent distrust or a heightened scrutiny standard applied
by human reviewers to AI-generated code? This ambiguity presents a
challenge to establishing a clear causal interpretation of the
results.</p>
<p>本文通过实证研究深入探讨了代码重构与软件缺陷之间的复杂关系。</p>
<h1 id="研究背景与动机-1">研究背景与动机</h1>
<h2 id="传统认知">传统认知</h2>
<ul>
<li>Bug修复：纠正性修改，旨在消除程序缺陷</li>
<li>代码重构：行为保持的代码改进，旨在提升内部质量而不改变功能</li>
<li>传统观点认为这两种活动应该独立进行，且重构不应引入缺陷</li>
</ul>
<h2 id="研究动机-1">研究动机</h2>
<ul>
<li>实际开发中，开发者对重构存在顾虑，担心引入缺陷</li>
<li>现有研究对重构与缺陷关系的结论不一致</li>
<li>需要基于大规模实证数据探究重构与缺陷的真实关系</li>
</ul>
<h1 id="研究问题">研究问题</h1>
<h2
id="rq1bug修复提交中是否常见混杂重构更改">RQ1：Bug修复提交中是否常见混杂重构更改？</h2>
<ul>
<li>探究开发者在修复缺陷时是否同时进行重构</li>
</ul>
<h2
id="rq2重构操作是否出现在引入缺陷的代码修改中">RQ2：重构操作是否出现在引入缺陷的代码修改中？</h2>
<ul>
<li>分析重构是否真的可能引入新的缺陷</li>
</ul>
<h2
id="rq3在引入缺陷的提交中哪些重构类型最为常见">RQ3：在引入缺陷的提交中，哪些重构类型最为常见？</h2>
<ul>
<li>识别高风险的重构类型，为开发者提供预警</li>
</ul>
<h1 id="研究方法">研究方法</h1>
<h2 id="数据来源">数据来源</h2>
<ul>
<li>SmartSHARK 2.2 数据集</li>
<li>涵盖96个Java项目</li>
<li>包含提交标签、重构操作、缺陷引入信息</li>
</ul>
<h2 id="分析工具">分析工具</h2>
<ul>
<li>重构检测：RMiner工具（精度98%，召回率87%）</li>
<li>缺陷引入识别：基于SZZ算法</li>
<li>提交级别关联分析</li>
</ul>
<h2 id="分析方法">分析方法</h2>
<ul>
<li>通过提交ID关联重构与缺陷记录</li>
<li>统计共现频率</li>
<li>识别高风险重构类型</li>
</ul>
<h1 id="主要研究发现">主要研究发现</h1>
<h2
id="rq1bug修复提交中的重构混杂情况">RQ1：Bug修复提交中的重构混杂情况</h2>
<ul>
<li>41/96个项目存在重构与bug修复混杂的提交</li>
<li>平均21%的bug修复提交包含重构操作</li>
<li>最高比例：Calcite项目（41%）</li>
<li>但仅有10%的重构操作与bug修复混杂</li>
</ul>
<h2
id="rq2重构在缺陷引入提交中的出现情况">RQ2：重构在缺陷引入提交中的出现情况</h2>
<ul>
<li>平均54%的缺陷引入提交包含重构操作</li>
<li>比例范围：20%（commons-validator）到71%（Calcite）</li>
<li>重构与缺陷引入存在显著共现关系</li>
</ul>
<h2 id="rq3高风险重构类型识别">RQ3：高风险重构类型识别</h2>
<h3 id="高频出现类型按次数">高频出现类型（按次数）</h3>
<ul>
<li>Change Variable Type（652次）</li>
<li>Extract Method（454次）</li>
<li>Change Return Type（338次）</li>
</ul>
<h3 id="高风险类型按比例r1">高风险类型（按比例R1%）</h3>
<ul>
<li>Extract Subclass（33%出现在缺陷引入提交中）</li>
<li>Replace Attribute（29%）</li>
<li>Move and Rename Attribute（28%）</li>
</ul>
<h1 id="结论与启示">结论与启示</h1>
<h2 id="主要结论">主要结论</h2>
<ul>
<li>重构与缺陷活动在实践中并非独立</li>
<li>重构并非总是"安全"的行为保持操作</li>
<li>特定重构类型具有较高风险</li>
</ul>
<h2 id="实践启示">实践启示</h2>
<ul>
<li>重构时应加强验证与测试，特别是高风险类型</li>
<li>避免在修复缺陷时混杂不相关的重构</li>
<li>提高对重构潜在风险的认识</li>
</ul>
<h2 id="研究局限性">研究局限性</h2>
<ul>
<li>基于提交级别的共现分析，未建立因果关系</li>
<li>依赖检测工具的准确性（RMiner、SZZ）</li>
<li>数据集局限于Java项目</li>
</ul>
<h1 id="未来工作">未来工作</h1>
<h2 id="定性研究">定性研究</h2>
<ul>
<li>深入分析重构与缺陷之间的因果关系</li>
<li>探究重构引入缺陷的根本机制</li>
</ul>
<h2 id="扩展研究">扩展研究</h2>
<ul>
<li>扩展到更多编程语言和项目类型</li>
<li>开发重构风险评估工具</li>
<li>建立重构最佳实践指南</li>
</ul>
<h1 id="总结">总结</h1>
<p>本研究通过实证分析挑战了"重构总是安全"的传统观念，揭示了重构与缺陷之间的复杂关联，为开发者理解和管理重构风险提供了重要依据。</p>
<h1 id="可以提出的问题-1">可以提出的问题：</h1>
